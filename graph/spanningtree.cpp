#include<iostream>
#include<vector>
#include <algorithm>
#include <queue>
using namespace std;
struct Edge {

	int weight;
	int head;
	int tail;
	Edge(int weight, int head, int tail) {
		this->weight = weight;
		this->head = head;
		this->tail = tail;
	}
	bool operator<(const Edge& e) {
		return weight < e.weight;
	}

};

//写一个并查集，负责查和并
class UnionFind {
private:
	vector<int> parent;
public:
	UnionFind(int n) {
		for (int i = 0; i < n; i++) {
			parent.push_back(i);
		}
	}
	int find(int x) {
		//先写终止条件
		//如果父节点是自己，那么就是找到了根节点
		if (parent[x] == x) {
			return x;
		}
		else {
			//使用路径压缩
		//本来是链状的，现在全部变成树状
			//含义是如果x的父节点不是根节点，那么更改x的父节点为x父节点的父节点，以此类推，直到更改到根节点为止
			parent[x] = find(parent[x]);
			return parent[x];
		}
	}
	//合并函数
	bool Union(int x, int y) {
		//一定要把root节点单独拎出来，否则只修改了一个人的root，同一个分路上的root没有修改
		int rootx = find(x);
		int rooty = find(y);
		if (parent[x] == parent[y]) {
			return 0;
		}
		else {
			//否则，合并
				//把x分父节点变成y的父节点
			parent[rootx] = rooty;

			return 1;
		}
	}
};
class kruskalSolution {

public:
	vector<Edge> kruskal(vector<Edge> edges, int n, int total_weight = 0) {
		UnionFind uf(n);
		//然后对边集按照权重进行排序
		sort(edges.begin(), edges.end());
		//创建一个空的边集
		vector<Edge>mst;
		//遍历边集当中的每个边
		for (auto const& edge : edges) {
			if (uf.find(edge.head) == uf.find(edge.tail)) {
				continue;
			}
			else {
				total_weight += edge.weight;
				mst.push_back(edge);
				uf.Union(edge.head, edge.tail);
			}
		}
		return mst;
	}
};

//------------------------------------------Prim算法实现----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//使用领接表来存储图vector<vector<pair<int,int>>> adj
//adj[u]表示包含若干个pair ，每个pair的组成是{邻居节点v,边权 w},表示与u相连接的点是v,然后这个边的权重是w
//最终返回的是树的权重
class primSolution {
public:
	int prim(int n, vector<vector<pair<int, int>>> adj) {
		int total_weight = 0;

		//核心数据结构
		vector<bool>visited(n, 0); //初始里面包含了n个元素，每个元素都是false
		vector<int>min_dist(n, INT_MAX);

		//最小堆来存储pair<distance,node>
		//priority_queue< T, Container, Compare >
		//T是数据类型
		//container是存储数据的容器，默认是deque
		priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

		//初始化起点
		min_dist[0] = 0;

		pq.push(make_pair(0, 0));

		//主循环,当队列不为空时，进行以下操作
		while (!pq.empty()) {
			//取出堆顶元素
			int d = pq.top().first;
			int u = pq.top().second;

			if (visited[u]) {
				continue;
			}

			//如果没有被访问，则加入到已访问集合中
			visited[u] = true;
			total_weight += d;

			//接下来就要更新队列中的元素了
			//先找出所有相邻的边
			//edge=<v,d>
			for (auto& edge : adj[u]) {
				int v = edge.first;
				int d = edge.second;

				//判断新的点的权重是否比当前最小的权重小
				if (visited[v] == false && d < min_dist[v]) {
					//入堆
					min_dist[v] = d;
					pq.push(make_pair(d, v));
				}
			}

		}
		return total_weight;
	}
};
